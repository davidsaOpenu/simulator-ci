---
- hosts: localhost
  connection: local

  vars:
    - dest: "{{ ansible_env.HOME }}/simulator"
    - ref: refs/heads/master
    - guest_ssh_port: 2222
    - memory: 2048
    - smp: 4
    - hda: "{{ ansible_env.HOME }}/hda.img"
    - kernel_image: vmlinuz-3.8.0-29-generic
    - initrd_image: initrd.img-3.8.0-29-generic
    - kernel_cmdline: "BOOT_IMAGE=/boot/{{kernel_image}} root=UUID=063018ec-674c-4c3e-a976-ac4fa950864f ro"
    - qemu_pid_file: "{{ ansible_env.HOME }}/simulator_qemu.pid"

  tasks:
    - include: simulator.yml

    - name: disable SSD monitor
      patch: src=patches/qemu-monitor-off.patch basedir={{ dest }} remote_src=yes strip=1

    - name: build qemu
      shell: chdir={{ dest }}/eVSSIM/QEMU
          ./configure --enable-io-thread --enable-linux-aio --target-list=x86_64-softmmu --enable-sdl --enable-vssim --extra-cflags='-Wno-error=unused-but-set-variable -Wno-error=deprecated-declarations' && make

    - name: ensure QEMU/hw/data exists
      file: path={{ dest }}/eVSSIM/QEMU/hw/data state=directory

    - name: mount tmpfs data
      become: true
      mount: fstype=tmpfs opts="size=16g" state=mounted src=tmpfs name={{ dest }}/eVSSIM/QEMU/hw/data

    - name: link SSD configuration
      file: path={{ dest }}/eVSSIM/QEMU/hw/data/ssd.conf src=../../../CONFIG/ssd.conf force=yes state=link

    # Newer version of SeaBIOS is required to allow booting directly with a Linux kernel image.
    - name: overwrite bios.bin
      copy:
      args:
        src: patches/bios.bin
        dest: "{{ dest }}/eVSSIM/QEMU/pc-bios/bios.bin"
        remote_src: yes

    - name: copy kernel
      copy:
      args:
        src: "patches/{{kernel_image}}"
        dest: "{{ dest }}/{{kernel_image}}"
        remote_src: yes

    - name: copy initrd
      copy:
      args:
        src: "patches/{{initrd_image}}"
        dest: "{{ dest }}/{{initrd_image}}"
        remote_src: yes

    # Ensure any old qemu process is stopped

    - name: get old qemu pid
      shell: read pid<{{qemu_pid_file}}; if [[ -n "$pid" && -e /proc/$pid/status ]]; then echo $pid; fi
      register: old_qemu_pid_task

    - name: shut down old guest
      shell: kill {{old_qemu_pid_task.stdout}}
      when: old_qemu_pid_task.stdout != ""

    - name: wait for old guest to shut down
      wait_for: path=/proc/{{old_qemu_pid_task.stdout}}/status state=absent

    # Start new qemu process

    - name: start guest
      shell: ../x86_64-softmmu/qemu-system-x86_64 -m {{memory}} -smp {{smp}} -hda {{hda}} -device nvme -redir tcp:{{guest_ssh_port}}::22 -nographic -vnc :0 -kernel "{{dest}}/{{kernel_image}}" -initrd "{{dest}}/{{initrd_image}}" -append "{{kernel_cmdline}}" -daemonize -pidfile "{{qemu_pid_file}}"
      args:
        chdir: "{{ dest }}/eVSSIM/QEMU/hw"

    - name: waiting for guest to start
      wait_for:
      args:
        port: "{{guest_ssh_port}}"
        delay: 30
        search_regex: OpenSSH
        timeout: 10000

    - name: ssh into guest
      shell: sshpass -p esd ssh -p "{{guest_ssh_port}}" -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no esd@127.0.0.1 uname
      register: guest_uname

    # Should display "Linux"

    - debug:
      args:
        msg: "Output of 'ssh uname' to guest: {{ guest_uname.stdout }}"

    # Shutdown qemu and confirm it has gone down

    - name: get existing qemu pid
      shell: read pid<{{qemu_pid_file}}; if [[ -n "$pid" && -e /proc/$pid/status ]]; then echo $pid; fi
      register: qemu_pid_task

    - name: shut down guest
      shell: kill {{qemu_pid_task.stdout}}
      when: qemu_pid_task.stdout != ""

    - name: wait for guest to shut down
      wait_for: path=/proc/{{qemu_pid_task.stdout}}/status state=absent

    - debug: msg="Done running tests on {{ ref }}, target is in {{ dest }}"
