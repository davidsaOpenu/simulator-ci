- name: test whether hda.img exists
  stat:
  args:
    path: "{{hda_img}}"
    get_checksum: False
    get_md5: False
  register: hda_file

- name: download hda.img
  shell: "test -e {{hda_zip}} || curl -L -o {{hda_zip}} 'https://www.dropbox.com/s/6v13efgzmcidgao/hda.zip'"
  args:
    # get_url module doesn't seem to follow redirects, curl just works
    warn: no
  when: hda_file.stat.exists == false

- name: unarchive hda.img
  unarchive: "copy=no src={{hda_zip}} dest={{hda_dir}}"
  when: hda_file.stat.exists == false

- name: delete hda archive
  file: "path={{hda_zip}} state=absent"
  when: hda_file.stat.exists == false

- name: build qemu
  shell: chdir={{ dest }}/eVSSIM/QEMU
      ./configure --enable-io-thread --enable-linux-aio --target-list=x86_64-softmmu --enable-sdl --enable-vssim --extra-cflags='-Wno-error=unused-but-set-variable -Wno-error=deprecated-declarations -Wno-error=cpp' --cc={{ gcc }} --enable-xen && make

- name: ensure QEMU/hw/data exists
  file: path={{ dest }}/eVSSIM/QEMU/hw/data state=directory

- name: mount tmpfs data
  become: true
  mount: fstype=tmpfs opts="size=16g" state=mounted src=tmpfs name={{ dest }}/eVSSIM/QEMU/hw/data

- name: link SSD configuration
  file: path={{ dest }}/eVSSIM/QEMU/hw/data/ssd.conf src=../../../CONFIG/ssd.conf force=yes state=link

# Newer version of SeaBIOS is required to allow booting directly with a Linux kernel image.
- name: overwrite bios.bin
  copy:
  args:
    src: bios.bin
    dest: "{{ dest }}/eVSSIM/QEMU/pc-bios/bios.bin"

- name: copy kernel
  copy:
  args:
    src: "{{kernel_image}}"
    dest: "{{ dest }}/{{kernel_image}}"

- name: copy initrd
  copy:
  args:
    src: "{{initrd_image}}"
    dest: "{{ dest }}/{{initrd_image}}"

# Ensure any old qemu process is stopped

- name: get old qemu pid
  shell: 'read pid<{{qemu_pid_file}}; if [[ -n "$pid" && -e /proc/$pid/status ]]; then echo $pid; fi'
  args:
      # using bashisms
      executable: /bin/bash
  register: old_qemu_pid_task
  tags: qemu

- name: shut down old guest
  shell: "kill {{old_qemu_pid_task.stdout}}"
  when: old_qemu_pid_task.stdout != ""
  tags: qemu

- name: wait for old guest to shut down
  wait_for:
  args:
      path: "/proc/{{old_qemu_pid_task.stdout}}/status"
      state: absent
  when: old_qemu_pid_task.stdout != ""
  tags: qemu

# Start new qemu process

- name: start guest
  shell: "../x86_64-softmmu/qemu-system-x86_64 -m {{memory}} -smp {{smp}} -hda '{{hda_img}}' -device nvme -redir tcp:{{guest_ssh_port}}::22 -nographic -vnc :0 -kernel '{{dest}}/{{kernel_image}}' -initrd '{{dest}}/{{initrd_image}}' -append '{{kernel_cmdline}}' -daemonize -pidfile '{{qemu_pid_file}}' -machine {{qemu_machine}}"
  args:
    chdir: "{{ dest }}/eVSSIM/QEMU/hw"
  tags: qemu

- name: waiting for guest to start
  wait_for:
  args:
    port: "{{guest_ssh_port}}"
    search_regex: OpenSSH
    timeout: 10000
  tags: qemu

- name: ssh into guest
  delegate_to: "{{inventory_hostname}}__guest"
  shell: "uname"
  register: guest_uname
  tags: qemu

# Should display "Linux"

- debug:
  args:
    msg: "Output of 'ssh uname' to guest: {{ guest_uname.stdout }}"
  tags: qemu

# Shutdown qemu and confirm it has gone down

- name: get existing qemu pid
  shell: 'read pid<{{qemu_pid_file}}; if [[ -n "$pid" && -e /proc/$pid/status ]]; then echo $pid; fi'
  args:
      # using bashisms
      executable: /bin/bash
  register: qemu_pid_task
  tags: qemu

- name: shut down guest
  shell: "kill {{qemu_pid_task.stdout}}"
  when: qemu_pid_task.stdout != ""
  tags: qemu

- name: wait for guest to shut down
  wait_for:
  args:
      path: "/proc/{{qemu_pid_task.stdout}}/status"
      state: absent
  tags: qemu

- debug: "msg=Done running tests on {{ ref }}, target is in {{ dest }}"
  tags: qemu
